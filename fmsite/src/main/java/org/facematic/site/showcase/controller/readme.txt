[h1]Controller[/h1]

Я не буду бодаться в терминологической полемике в вопросв о том, что должен и что не должен делать контроллер.
В данном случае концепция проста и выражается формулировкой: "есть то, что действует и то, что подлежит действию".
То, что действует - это контроллер.
Базовая модель связи view с controller такова:
Контроллер реализуется Java - классом, имя которого прописывается в описании view.
При конструировании view, facematic-engine создает экземпляр контроллера, 
в поля которого записывает ссылки на ключевые элементы представления в соответствии 
с предписаниями разметки представления.

[h2]VIEW[/h2]  
В нашем примере описание вида:  
<content ... controller="org.facematic.site.showcase.controller.ControllerExample" >

Говорит о том, что сконструированный по данному описанию view будет иметь дело с экземпляром контроллера, 
реализованным Java - классом org.facematic.site.showcase.controller.ControllerExample.

Описание также содержит ключевые элементы:

TextField с именем theTextField.
<TextField name="theTextField" width="100%" />

Кнопки с именами theButton, oneMoreButton, описанные в виде:

		<Button name="theButton" caption="click me" onClick="theButtonClicked" width="100%" />
		<Button name="oneMoreButton" caption="click me too" width="100%" />

При этом  кнопка theButton предполагает, что класс контроллера имеет метод theButtonClicked.


[h2]Controller[/h2]

В нашем примере класс контроллера имплементирует интерфейс FmBaseController. Это не обязательное правило. 
Просто имея дело с наследниками FmBaseController, facematic-engine выполнит два обязательных действия:
1. Предоставит нам возможность определить контекст создания VIEW вызвав FmBaseController.prepareContext (FaceProducer producer). 
Здесь producer - это экземпляр продьюсера, который будет заниматься конструированием нашего View. В prepareContext, таким образом, мы можем косвенно повлиять например на данные, 
которые будут использоваться при конструировании View. Теме FaceProducer вообще - то надо посвятить отдельный раздел, но в контексте данного примера это не важно. 
Просто отметим для себя, что такая возможность есть. В подавляющем большинстве случаев эта возможность не используется.
2. Вызовет init в тот момент, когда все элементы view уже будут созданы, скомпонованы и ссылки на ключевые элементы будут содержаться в полях нашего класса.

Далее обратим внимание на поля класса:

В поле, помеченное аннотацией @FmUI будет помещена ссылка на экземпляр UI в рамках которого работает View, контролируемый данным контроллером.
@Inject можно опустить. Facematic - аннотации имеют более высокий приоритет, так, как приложение может работать не в CDI - окружении.
 
	@Inject
	@FmUI
	FacematicUI ui;  

В поле, помеченное аннотацией @FmViewComponent(name = "...") будет помещена ссылка на Vaadin-элемент, созданны по описанию, в котором указано соответствующее имя name.
Так:

	@FmViewComponent(name = "theTextField")
	TextField theTextField;

    theTextField будет ссылаться на vaadin - элемент созданный по описанию 
 	<TextField name="theTextField" width="100%"></TextField>
 
 При этом имя, указанное в аннотации имеет более высокий приоритет, чем имя переменной. Но если имя в аннотации опустить, то надо обеспечить, 
 чтобы имя самой переменной соответствовало имени, определенному разметкой. Иными словами, для нашей разметки
 	<TextField name="theTextField" width="100%"></TextField>
мы можем описать поле контроллера одним из способов:

	@FmViewComponent(name = "theTextField")
	TextField theTextField;
	
  	или
  	
 	@FmViewComponent
	TextField theTextField;
	
	или
	
	@FmViewComponent(name = "theTextField")
	TextField myField;
	
 [b]Поле view[/b]
 Помимо заявленных разметкой ключевых элементов, facematic-engine определит в контроллере значение поля, описанного в виде
 	@FmViewComponent(name = "view")
	VerticalLayout view;
  
 Имя view - системное. Поле контроллера, описанное таким образом будет содержать ссылку на весь View, построенный по описанию.
 
 [h2]public void init ()[/h2]
 Вернемся методу init нашего контроллера. (Помним, что он будет вызван только в случае, если наш контроллер имплементирует интерфейс FmBaseController.)
 К моменту, когда facematic-engine вызовет init нашего контроллера, все поля, ссылающиеся на элементы интерфейса уже будут определены.
 Нам остается только выполнить с этими полями необходимые действия, привязав к ним нужные реакции, или доопределив необходимые свойства (например, если свойства определяются 
 конкретным контекстом приложения на момент конструирования нашего контроллера).
 
 В нашем примере описание кнопки oneMoreButton не предписывает никакого поведения. Поэтому в методе init мы определяем это поведение:
 
 		oneMoreButton.addClickListener(new Button.ClickListener() {
			@Override
			public void buttonClick(ClickEvent event) {
				showEnteredText(theTextField.getValue());

			}
		});
 
 Кроме того, в нашем примере, в момент инициализации мы заносим предопределенный текст в текстовое поле:
 
 		theTextField.setValue("Enter text here");

Таким образом, метод Init нашего контроллера имеет вид:

	@Override
	public void init() {
		theTextField.setValue("Enter text here");

		oneMoreButton.addClickListener(new Button.ClickListener() {
			@Override
			public void buttonClick(ClickEvent event) {
				showEnteredText(theTextField.getValue());

			}
		});
	}

[h2]Предписанные реакции[/h2]
Я ужя упоминал, что описание одной из кнопок в нашем примере предписывает контроллеру иметь метод, который отработает реакцию на нажатие этой кнопки.
		<Button name="theButton" caption="click me" onClick="theButtonClicked" width="100%" />

Поэтому в нашем контроллере мы реализуем этот метод:

	@FmReaction("Button#theButton.onClick")
	public void theButtonClicked() {
		showEnteredText(theTextField.getValue());
	}
  
Аннотация @FmReaction(...) является необязательной и нужна только для улучшения читабельности кода.
В напем случае мы предписываем экземпляру контроллера по нажатию на кнопку theButton отобразить Notification, содержащий текст из TextField theTextField.


В заключении надо сказать, что не каждый View обязан иметь собственный контроллер. Так, например, мы можем иметь набор описанных view, каждый(или некоторые) 
из которых не имеют собственного контроллера, но используются для сборки сложного контента, управляемого специфичным для этого контента контроллером.
